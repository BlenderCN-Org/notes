...menustart

 - [edX  Introduction to Kuberneters](#e017284a962c40a7dc29fd29bea64bb4)
 - [Access Kuberneters](#10ebfd4c6ede5e99a80eb32105dc4419)
     - [HTTP API Space of Kubernetes](#c9157975d6f67292424e86421d6ca49c)
     - [kubectl Configuration File](#70becb84ec118d75e27f125448562a2b)
     - [Kubernetes dashboard](#6bbde18895b093a1a0fc79b5c02e4462)
         - [Deploying the Dashboard UI](#ae1fd03692378014b99c5c70b6c121af)
         - [Accessing the Dashboard UI](#f32d0f539f9fbaff4c670cd2e5d7b14d)
         - [APIs - with 'kubectl proxy'](#d7dba71d2e1aa5aea658e819489eab4d)
         - [APIs - without 'kubectl proxy'](#c4a8eba76a7943e2e98a2e8b0f014db3)

...menuend


<h2 id="e017284a962c40a7dc29fd29bea64bb4"></h2>

# edX  Introduction to Kuberneters


<h2 id="10ebfd4c6ede5e99a80eb32105dc4419"></h2>

# Access Kuberneters

<h2 id="c9157975d6f67292424e86421d6ca49c"></h2>

## HTTP API Space of Kubernetes

![](https://raw.githubusercontent.com/mebusy/notes/master/imgs/k8s-api-server-space.jpg)

HTTP API space of Kubernetes can be divided into three independent groups:

 - Core Group (/api/v1)
    - This group includes objects such as Pods, Services, nodes, etc.
 - Named Group
    - This group includes objects in **/apis/$NAME/$VERSION** format
    - These different API versions imply different levels of stability and support:
        - Alpha level - it may be dropped at any point in time, without notice. For example, /apis/batch/v2alpha1.
        - Beta level - it is well-tested, but the semantics of objects may change in incompatible ways in a subsequent beta or stable release. 
            - example, /apis/certificates.k8s.io/v1beta1
        - Stable level - appears in released software for many subsequent versions.
            - For example, /apis/networking.k8s.io/v1
 - System-wide
    - This group consists of system-wide API endpoints, like /healthz, /logs, /metrics, /ui, etc.

<h2 id="70becb84ec118d75e27f125448562a2b"></h2>

## kubectl Configuration File

 - To connect to the Kubernetes cluster, kubectl needs the master node endpoint and the credentials to connect to it.
 - On the master node machine, by default, a configuration file, config, inside the.kube directory, which resides in the user's home directory.
 - That configuration file has all the connection details.  
 - To look at the connection details, we can either see the content of the ~/.kube/config(Linux) file, or run the following command:


```
# kubectl config view
apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: DATA+OMITTED
    server: https://10.192.83.78:6443
  name: kubernetes
...
```

 - Once kubectl is installed, we can get information about the Minikube cluster with the `kubectl cluster-info` command

```
# kubectl cluster-info
```


<h2 id="6bbde18895b093a1a0fc79b5c02e4462"></h2>

## Kubernetes dashboard 

<h2 id="ae1fd03692378014b99c5c70b6c121af"></h2>

### Deploying the Dashboard UI

```
kubectl create -f https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml
```

<h2 id="f32d0f539f9fbaff4c670cd2e5d7b14d"></h2>

### Accessing the Dashboard UI

```
kubectl proxy
```

 - Kubectl will make Dashboard available at
    - `http://localhost:8001/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy/`

<h2 id="d7dba71d2e1aa5aea658e819489eab4d"></h2>

### APIs - with 'kubectl proxy'

 - When kubectl proxy is configured, we can send requests to localhost on the proxy port:
    - With the above curl request, we requested all the API endpoints from the API server.

```
$ curl http://localhost:8001/
{
 "paths": [
   "/api",
   "/api/v1",
   "/apis",
   "/apis/apps",
   ......
   ......
   "/logs",
   "/metrics",
   "/swaggerapi/",
   "/ui/",
   "/version"
 ]
}
```

<h2 id="c4a8eba76a7943e2e98a2e8b0f014db3"></h2>

### APIs - without 'kubectl proxy'

 - Without **kubectl proxy** configured, we can get the **Bearer Token** using kubectl,and then send it with the API request.
 - A **Bearer Token** is an **access token** which is generated by the authentication server(the API server on the master node) and given back to the client. 
 - Using that token, the client can connect back to the Kubernetes API server without providing further authentication details, and then, access resources. 

 - **Get the token**

```
TOKEN=$(kubectl describe secret -n kube-system $(kubectl get secrets -n kube-system | grep default | cut -f1 -d ' ') | grep -E '^token' | cut -f2 -d':' | tr -d '\t' | tr -d " ")
```

 - **Get the API server endpoint**


```
APISERVER=$(kubectl config view | grep https | cut -f 2- -d ":" | tr -d " ")
# echo $APISERVER
https://10.192.83.78:6443
```

 - Access the API Server using the curl command, as shown below

```
curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure
{
  "kind": "APIVersions",
  "versions": [
    "v1"
  ],
  "serverAddressByClientCIDRs": [
    {
      "clientCIDR": "0.0.0.0/0",
      "serverAddress": "10.192.83.78:6443"
    }
  ]
}
```

# Kubernetes Building Blocks

## Kubernetes Object Model

 - With each object, we declare our intent or desired state using the **spec** field
 - The Kubernetes system manages the **status** field for objects, in which it records the actual state of the object. 
 - To create an object, we need to provide the **spec** field to the Kubernetes API server. 
    - The spec field describes the desired state, along with some basic information, like the name. 
 - Below is an example of a Deployment object:

```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
```

 - kind
    - mention the object type
 - metadata
    - attach the basic information to objects, like the name.
 - spec
    - define the desired state of the deployment.
    - You may have noticed that in our example we have two spec fields (spec and spec.template.spec).
    - In our example, we want to make sure that, at any point in time, at least 3 Pods are running, which are created using the Pods Template defined in spec.template.
    - In spec.template.spec, we define the desired state of the Pod.
        - Here, our Pod would be created using nginx:1.7.9.
 - Once the object is created, the Kubernetes system attaches the **status** field to the object; we will explore it later.

## Pods

 - A Pod is the smallest and simplest Kubernetes object.
    - It is the unit of deployment in Kubernetes, which represents a single instance of the application. 
 - A Pod is a logical collection of one or more containers, which:
    - Are scheduled together on the same host
    - Share the same network namespace
    - Mount the same external storage (volumes).

![](https://raw.githubusercontent.com/mebusy/notes/master/imgs/k8s_pod.png)

 - Pods do not have the capability to self-heal by themselves. 
    - That is why we use them with controllers, which can handle a Pod's replication, fault tolerance, self-heal, etc. 
    - Examples of controllers are Deployments, ReplicaSets, ReplicationControllers, etc.
 - We attach the Pod's specification to other objects using Pods Templates, as we have seen in the previous section.


## Labels

 - Labels are key-value pairs that can be attached to any Kubernetes objects (e.g. Pods).
 - Labels are used to organize and select a subset of objects, based on the requirements in place.
 - Many objects can have the same Label(s). Labels do not provide uniqueness to objects.  



 - In the image above, we have used two Labels: app and env.
    - Based on our requirements, we have given different values to our four Pods.

